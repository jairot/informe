\chapter{Arquitectura}

A todas las palabras de todos los paquetes que ingresan a la interfaz de acceso a la cabecera, se le anexan 8 bits que contienen el valor de los campos de control que corresponden a esa palabra y ademas 3 bits libres en donde se pondra la etiqueta con los resultados de lo procesado en el software. En la figura\ref{fig:datocontrol}  es posible ver el valor de cada uno de estos campos.

\begin{figure}[H]
  \centering
	\includegraphics[scale=0.40]{3-arquitectura/graf/datocontrol.eps}
  \caption{Bits de Control anexados a cada palabra}
  \label{fig:datocontrol}
\end{figure}

Para ilustrar el funcionamiento del sistema se puede observar en la figura~\ref{fig:interfaz1} el estado de los datos y los bits de control del paquete en cada uno de los módulos que integran la Interfaz de Acceso a la Cabecera.

\begin{figure}[H]
  \centering
	\includegraphics[scale=0.60]{3-arquitectura/graf/moduloexp.eps}
  \caption{Estado del campo de control}
  \label{fig:interfaz1}
\end{figure}

\section{Generador}

Con la intención de simplificar el desarrollo y el futuro Debugging del proyecto se remplazo la interfaz de red por un generador de paquetes.

\begin{figure}[H]
  \centering
	\includegraphics[scale=0.60]{3-arquitectura/graf/bloqgenerador.eps}
  \caption{Modulo generador de Paquetes}
  \label{fig:gen}
\end{figure}


El mismo cuenta con las siguientes capacidades

\begin{itemize}
	\item Permite iniciar la generación de paquetes desde un interruptor externo.
	\item Es posible parametrizar la distancia, en ciclos de clock, entre la generación de un paquete y el siguiente.
	\item Puede generar una cantidad variable de paquetes, con valores diferentes en sus campos.
	\item Mantiene un contador global de la cantidad de paquetes generados y lo imprime en la ultima palabra del Payload de cada uno.
\end{itemize}

Este modulo es una versión adaptada del generador usado en otros proyectos integradores desarollados en el Laboratorio de Comunicaciones Digitales, que a su vez es una versión mejorada de un generador que esta disponible en Opencores.

\section{Interfaz de Acceso a la Cabecera}
En base a la figura~\ref{fig:inter} se pasara a describir de manera detallada la estructura y el funcionamiento de cada uno de los módulos que componen la Interfaz de Acceso a la Cabecera. 

\subsection{FIFO}
Se trata de una FIFO estándar, basada en un código disponible en OpenCores, que soporta palabras de 72 bits, 64 del paquete y 8 de control. Como capacidad extra se le agrego un mecanismo para controlar la integridad de los paquetes que ingresan, aceptando solo los que pueden ser almacenados completamente en la memoria interna. 

\begin{figure}[H]
  \centering
	\includegraphics[scale=0.60]{3-arquitectura/graf/bloqfifo.eps}
  \caption{FIFO}
  \label{fig:gen}
\end{figure}

\subsection{Delay Buffer}
Este modulo fue desarrollado íntegramente para este proyecto, esta compuesto por un registro de desplazamiento interno, que cuenta con 8 posiciones de 72 bits cada una. Su función principal es detectar la llegada de un paquete a la FIFO, cargar 5 palabras, correspondientes a la cabecera, y enviarle una copia a Uplink. Este modulo permite, además, desacoplar el flujo de datos de la comunicación con el Microprocesador.

La implementación de este modulo esta formada por una maquina de estados(Figura~\ref{fig:dbstate}) descripta a continuación:

\begin{figure}[H]
  \centering
	\includegraphics[scale=0.50]{3-arquitectura/graf/estdelaycompleto.eps}
  \caption{Maquina de estados de Delay Buffer}
  \label{fig:dbstate}
\end{figure}

\begin{itemize}
	\item IDLE: Es el estado inicial en el que se encuentra la maquina, cuando se detecta la presencia de datos en la FIFO pasa a SOP.
	\item SOP: Este estado es el encargado de validar la integridad de los paquetes, permitiendo iniciar el proceso solo cuando lo que hay en la entrada del bus de datos es un indicador de Inicio de Paquete(SOP)
	\item LOAD, WAIT1, WAIT3: Estos tres estados se alternan para ir sacando de la FIFO las 5 palabras correspondientes a la cabecera, implementan además mecanismos para manejar paquetes mas pequeños que 5 palabras.
	\item ENABLE, HOLD: Son los estados que se encargan de poner a disposición de Uplink la Cabecera completa y quedar a la espera de los resultados.
	\item WAIT2, UNLOAD: Estos estados se encargan de extraer de la FIFO las palabras restantes del paquete desplazando los espacios de memoria ya cargados. 
	\item OUTPUT: Se encarga de vaciar el registro de desplazamiento llenándolo de ceros a medida que se va poniendo las palabras del paquete a la salida. 
\end{itemize}

La ubicación de los datos en el registro de desplazamiento interno es representativo del funcionamiento del sistema y se muestra gráficamente en las figura~\ref{fig:regdata}
\begin{figure}[H]
  \centering

	\includegraphics[scale=0.70]{3-arquitectura/graf/regdespl01.eps}


   \hspace{1\linewidth}
	\includegraphics[scale=0.70]{3-arquitectura/graf/regdespl02.eps}



  \caption{Datos en el Registro de desplazamiento en cada estado }
  \label{fig:regdata}
\end{figure}




A continuación se presentan las señales que integran el modulo, con su correspondiente descripción:

\begin{figure}[H]
  \centering
	\includegraphics[scale=0.60]{3-arquitectura/graf/bloqdelaybuffer.eps}
  \caption{Delay Buffer}
  \label{fig:dbuffer}
\end{figure}


\begin{table}
	\begin{tabular}{|c|c|p{9cm}|} \hline
\rowcolor[gray]{0.1} \textcolor{white}{Nombre} & \textcolor{white}{Activo} & \textcolor{white}{Descripción}\\ \hline
\rowcolor[gray]{0.75} i\_data[71:0]	& N/A & Palabra de 72 bits que viene de la FIFO\\ \hline
\rowcolor[gray]{0.75} i\_shift\_en & High & Indica la disponibilidad de los resultados de la clasificación\\ \hline
\rowcolor[gray]{0.75} i\_fifo\_empty & Low & Señala la presencia de datos en en la FIFO\\ \hline
\rowcolor[gray]{0.9} o\_data[71:0] & N/A & Salida conectada a la ultima posición del registro de desplazamiento\\ \hline
\rowcolor[gray]{0.9} o\_header[359:0] & N/A & Bus interno por el que puede viajar las 5 palabras de la cabecera en un solo ciclo\\ \hline
\rowcolor[gray]{0.9} o\_header\_rdy & High & Indica la disponibilidad de la cabecera en oheader \\ \hline
\rowcolor[gray]{0.9} o\_fifo\_ren & High & Sirve para indicar a la fifo que se necesita una palabra nueva\\ \hline
 i\_clk & N/A & Señal de Reloj\\ \hline
 i\_rst & High & Reset\\ \hline
	\end{tabular}
	\caption{Señales de Delay Buffer}
	\label{tab:sigdb}
\end{table}


\subsection{Uplink}
El modulo Uplink lleva la comunicación entre el procesador y el resto de la Interfaz de acceso a la cabecera. Esta configurado para trabajar con las señales del bus Avalon(Apéndice B) y en caso de que se desee portar esta interfaz para interactuar con otro tipo de bus, solo es necesario modificar este bloque.

Se prepararon dos versiones de Uplink, una que transfiere al procesador la cabecera completa en 15 palabras de 32 bits y otra que solo envía una palabra de 32bits correspondiente a la IP Destino. 

\begin{figure}[H]
  \centering
   \subfloat[15 palabras]{
	\includegraphics[scale=0.40]{3-arquitectura/graf/15pal.eps}
	        \label{fig:up151:a}         
    }

    \subfloat[1 palabra]{
        \label{fig:up151:b}         %% Etiqueta para la primera subfigura
	\includegraphics[scale=0.40]{3-arquitectura/graf/1pal.eps}}
   \hspace{0.1\linewidth}
  \caption{Diferentes Versiones de Uplink }
  \label{fig:up151}
\end{figure}

Este modulo implementa la maquina de estados que se puede ver en la figura~\ref{fig:inter} y se describe a continuación:

\begin{figure}[H]
  \centering
	\includegraphics[scale=0.45]{3-arquitectura/graf/estuplinkcompleto.eps}
  \caption{Uplink}
  \label{fig:estuplink}
\end{figure}

\begin{itemize}
	\item IDLE: Es el estado inicial en el que se encuentra la maquina, hasta que recibe la confirmación de que la cabecera esta disponible.
	\item READ,HOLD,WAIT: Estos estados se alternan para interrumpir y transmitir 1 o 15 palabras de 32bits al procesador.
	\item WRITE: Es el estado encargado de esperar que el procesador envié los resultados, para luego darle aviso a los otros componentes de la disponibilidad de los mismos.
\end{itemize}

En al tabla que sigue se puede ver las señales que componen el modulo con su correspondiente descripción:

\begin{figure}[H]
  \centering
	\includegraphics[scale=0.55]{3-arquitectura/graf/bloquplink.eps}
  \caption{Uplink}
  \label{fig:bloquplink}
\end{figure}
	
\begin{table}
	\begin{tabular}{|c|c|c|p{6cm}|} \hline
\rowcolor[gray]{0.1} \textcolor{white}{Nombre} & \textcolor{white}{I/O} & \textcolor{white}{Activo} & \textcolor{white}{Descripción}\\ \hline
\rowcolor[gray]{0.75} i\_data[359:0] & Input & N/A & Bus interno por donde Delay Buffer envía la cabecera entera en un ciclo\\ \hline
\rowcolor[gray]{0.75} data\_avail & Input & High & Señala la disponibilidad de la Cabecera\\ \hline
\rowcolor[gray]{0.75} NIOS\_DATAout[31:0] & Input & N/A & Bus de datos desde el procesador\\ \hline
\rowcolor[gray]{0.75} NIOS\_ADDR[2:0] & Input & N/A & Bus de direcciones Avalon\\ \hline
\rowcolor[gray]{0.75} NIOS\_CSn & Input & Low & Señal Avalon que indica que se esta trabajando con este componente\\ \hline
\rowcolor[gray]{0.75} NIOS\_RDn & Input & Low & Indica que el procesador esta leyendo los datos presentes en NIOS\_DATAin \\ \hline
\rowcolor[gray]{0.75} NIOS\_WRn & Input & Low & Señala la disponibilidad de datos en NIOS\_DATAout\\ \hline
\rowcolor[gray]{0.9} NIOS\_DATAin[31:0] & Output & N/A & Bus de datos de entrada al procesador\\ \hline
\rowcolor[gray]{0.9} shift\_en & Output & High & Avisa a los otros componentes que ya están listos los resultados\\ \hline
\rowcolor[gray]{0.9} irq\_port & Output & High & Señal de Interrupción\\ \hline
 NIOS\_CLK, & Input & N/A & Señal de Reloj\\ \hline
 rst & Input & High & Reset\\ \hline
	\end{tabular}
	\caption{Señales de Uplink}
	\label{tab:sigup}
\end{table}

\newpage

\subsection{Write output}

Este modulo es el que se encarga de tomar el resultado emitido por el microprocesador y de estamparlo en los campos de control anexos a cada una de las palabras del paquete. Se puede ver en la figura~\ref{fig:inter} el diagrama de estados mediante el cual esta implementado este modulo y se describe cada estado a continuación:

\begin{figure}[H]
  \centering
	\includegraphics[scale=0.45]{3-arquitectura/graf/estwritecompleto.eps}
  \caption{Diagrama de Estados de Write Output}
  \label{fig:estuplink}
\end{figure}

\begin{itemize}
	\item IDLE: Es el estado inicial en el que se encuentra la maquina, hasta que recibe la confirmación de que los resultados están disponibles.
	\item READY: Espera que Delay Buffer le transmita la palabra correspondiente a un SOP. 
	\item OVERWRITE: Escribe el resultado en el Tag adjunto a cada palabra hasta que encuentra la palabra correspondiente a un EOP. 
\end{itemize}

Se detalla las señales de Entrada/Salida del modulo y su función:

\begin{figure}[H]
  \centering
	\includegraphics[scale=0.55]{3-arquitectura/graf/bloqwrite.eps}
  \caption{Uplink}
  \label{fig:bloquplink}
\end{figure}
	

\begin{table}
	\begin{tabular}{|c|c|p{9cm}|} \hline
\rowcolor[gray]{0.1} \textcolor{white}{Nombre} & \textcolor{white}{Activo} & \textcolor{white}{Descripción}\\ \hline
\rowcolor[gray]{0.75} i\_data[71:0]	& N/A & Palabra de 72 bits que viene Delay Buffer\\ \hline
\rowcolor[gray]{0.75} i\_shift\_en & High & Indica la disponibilidad de los resultados de la clasificación\\ \hline
\rowcolor[gray]{0.75} i\_result[32:0] & N/A! & Esta conectado a NIOS\_DATAout y guarda lo escrito por el procesador mientras i\_shift\_en esta activa \\ \hline
\rowcolor[gray]{0.9} o\_data[71:0] & N/A & Salida de las palabras con el resultado anexo\\ \hline
 i\_clk & N/A & Señal de Reloj\\ \hline
 i\_rst & High & Reset\\ \hline
	\end{tabular}
	\caption{Señales de Write Output}
	\label{tab:sigwo}
\end{table}


\begin{comment}

En este capítulos se detallara la arquitectura del proyecto en general, poniendo foco en la selección adecuada de las tecnologías a utilizar y completando el diseño obtenido en el capitulo anterior.

\section{Procesador Embebido}

Como se dijo en el capitulo 2, los microprocesadores embebidos en lógica programable se clasifican, básicamente, en dos tipos Hardcore y Softcore. Aunque los Hardcores ofrecen unas mejores prestaciones existen muy pocos dispositivos en el mercado que ofrecen este tipo de módulos y, en general, el costo de estos es mayor que el de uno que no cuenta con un Hardcore. Por estas razones de ahora en adelante se limitará el estudio a Softcores, siempre buscando que lo implementado siga los principios del diseño modular a los fines de facilitar la portabilidad.
\subsection{Estudio de los Softcores disponibles}
Los Softcores pueden ser clasificados en tres tipos según su origen

\begin{itemize}
	\item Provistos por los fabricantes de las FPGA
	\item Provistos por empresas distribuidoras de bloques IP(Intelectual Property)
	\item Provistos por la comunidad Open Source
\end{itemize}

\subsubsection{Provistos por los fabricantes de las FPGA}
Xilinx y Altera, los dos mayores fabricantes de FPGA, proveen un Softcore para integrar en sus dispositivos. La ventaja de este tipo de core es que se encuentran altamente integrados en las herramientas de desarrollo de dichos fabricantes, permitiendo montar un sistema embebido de manera gráfica e intuitiva. Además están a disposición del usuario una buena cantidad de  módulos IP para anexar al procesador y aumentar así sus funcionalidades. 

Dentro de las desventajas esta el hecho de que son dependientes de la plataforma y no es posible implementar el core propietario de Altera en un dispositivo Xilinx, y viceversa. Además se debe pagar una licencia por el uso de estos cores y no se cuenta con la posibilidad de observar o modificar el código de los mismos. 

Xilinx ofrece a los usuarios de sus dispositivos el MicroBlaze, un procesador RISC de 32 bits con una arquitectura muy similar al MIPS DLX. A nivel herramientas de desarrollo la empresa provee el "Xilinx's EDK(Embedded Development Kit)" que permite generar un sistema embebido completo con las interconexiones necesarias. Es posible correr el sistema operativo GNU/Linux en este tipo de procesador.

Altera por su parte ofrece la linea de Cores NIOS II, también RISC de 32 bits, que cuenta en tres variantes principales Nios II Fast, Economy y Standard y dos variantes especializadas Nios II SC core, para aplicaciones militares y aeroespaciales, y DesignWare IP, para implementar en ASIC. Altera provee además una interfaz de usuario para la construcción del sistema embebido llamado SOPC que se encuentra integrado a la herramienta Quartus y además el Nios II Embedded Design Suite (EDS) que permite diseñar el software requerido para cada aplicación. Soporta GNU/Linux.

\subsubsection{Provistos por empresas distribuidoras de bloques IP}
Existe una buena cantidad de empresas que se dedican a generar y comercializar bloques de propiedad intelectual (IP Cores o IP Blocks), unidades lógicas reusables que son propiedad intelectual de un individuo o empresa.
Varias de estas empresas cuentan con Softcores con distintas capacidades y tecnologías. La ventaja principal es la portabilidad de estos cores entre FPGA de distintos fabricantes. Entre las desventajas podemos nombrar la calidad de la documentación y la complejidad intrínseca que implica comprender y utilizar una herramienta de desarrollo de un tercero. 

Dentro de los mas conocidos se puede nombrar a la linea Leon de la empresa Aeroflex, LatticeMico32 de Lattice semiconductor o ARM cortex de Freescale. Los IP core pueden estar licenciados de diferentes formas incluidas entre ellas GPL.
 
\subsubsection{Provistos por la comunidad Open Source}
La comunidad open source se ha encargado de producir una buena cantidad de Softcores, las capacidades y perfomance de los mismos cubre casi todos los rangos. En la pagina web que lleva una lista de este tipo de proyectos, \textit{OpenCores.com}, se pueden encontrar alrededor de 130. El problema con este tipo de core esta en la poco uniforme calidad de la documentación y el funcionamiento deficiente de algunos de ellos. Sin embargo la flexibilidad para poder modificar la arquitectura a gusto y el costo cero de implementación son ventajas nada despreciables de estos productos. 

Se destaca el proyecto Openrisc 1200, que tiene una gran comunidad que lo soporta y algún prestigio ganado en este terreno.


\subsubsection{Tabla comparativa}
																																						 \newpage																												
\begin{table}


	\centering
	\begin{tabular}{|p{1.65cm}|p{1.98cm}|c|p{2.2cm}|p{1.5cm}|c|c|p{1.5cm}|} \hline
		Core & Arquitectura & Licencia & Profundidad del Pipeline & Ciclos por Instrucción & MMU & FPU & FPGA \\ \hline
		MicroBlaze & MicroBlaze & Propietaria & 3,5 & 1 & Opt & Opt & Xilinx\\ \hline
		Nios II/fast & Nios II & Propietaria & 6 & 1 & si & opt & Altera \\ \hline
		Nios II/std & Nios II & Propietaria & 5 & 1 & no & Opt & Altera \\ \hline
		Nios II/econ & Nios II & Propietaria & no & 6 & no & Opt & Altera \\ \hline
		LEON3 & SPARC-v8 & GPL & 7 & 1 & si & si & Xilinx, Altera, Lattice \\ \hline
		OpenRISC 1200 & OpenRISC 1000 & LGPL & 5 & 1 & si & no & Xilinx, Altera, Lattice \\ \hline
		Lattice Mico32 & Lattice Mico32 & Propietaria & 6 & 1 & no & no & Indep. \\ \hline
		Cortex-M1 & ARMv6 & Propietaria & 3 & 1 & no & no & Xilinx, Altera \\ \hline
	\end{tabular}
	\caption{Comparativa Softcores}
	\label{tab:comp}
\end{table}

\subsection{Criterios de Selección}

Los criterios de selección usados para elegir el Softcore que va a ser utilizado en este proyecto son:
\begin{itemize}
	\item Hardware: se debe contar con el dispositivo necesario para la implementación del Softcore.
	\item Herramientas de Diseño: la cadena de herramientas necesarias para diseñar el sistema y el software debe ser simple y funcional, para evitar que comprender las herramientas lleve mas tiempo que realizar el proyecto en sí mismo.
	\item Rendimiento: se desea alcanzar un rendimiento aceptable y que sea posible optimizarlo a medida de que el proyecto avanza.
\end{itemize}

Bajo estos criterios y teniendo en cuenta que en el laboratorio en que se realiza el presente proyecto integrador es posible acceder a una amplia variedad de kits de desarrollo equipados con FPGAs de Altera, todas las licencias de software y varios proyectos con antecedentes de haber puesto en funcionamiento un Nios II es este el Core seleccionado para el sistema embebido a implementar.



\subsection{Nios II}
El Nios II es un procesador RISC de 32 bits de propósito general que cuenta con las siguientes especificaciones:
\begin{itemize}
	\item Set de instrucciones, bus de datos y espacio de direcciones de 32 bits.
	\item 32 registros de propósito general.
	\item Soporte de hasta 32 interrupciones.
	\item Controlador de interrupciones externas para soportar una mayor cantidad de interrupciones.
	\item Multiplicación y división en una sola instrucción de 32 x 32 produciendo un resultado de 32-bits.
	\item Instrucciones dedicadas para multiplicaciones con resultados de 64 y 128 bits.
	\item Acceso a una variedad de periféricos e interfases a memorias  y periféricos fuera del chip.
	\item Modulo de depurado asistido por hardware.
	\item Unidad de manejo de memoria (MMU) opcional para soportar sistemas operativos mas complejos.
	\item Unidad de protección de memoria (MPU) opcional.
	\item Entorno de desarrollo de software basado en GNU C/C++ integrado a Eclipse.
	\item Integración con SignalTap® II, el analizador de lógica embebida de Altera permitiendo el análisis de tiempo real de todas las señales presentes en la FPGA.
	\item Set de instrucciones compatible entre todos las versiones del procesador Nios II.
\end{itemize}

Para poder ser implementado en una mayor variedad de dispositivos el Nios II ofrece 3 configuraciones diferentes:  Nios II/f (fast), Nios II/s (Standard), and Nios II/e (Economy).

\subsubsection{Nios II/e}
El Core Nios II/e esta diseñado para utilizar la menor cantidad de espacio posible. Esto esto funciona especialmente para FPGA de bajo costo. Tiene las siguientes características:
\begin{itemize}
	\item Espacio de direcciones de hasta 2GB
	\item Gratuito, no requiere licencia 
\end{itemize}

\subsubsection{Nios II/s}
El Nios II/s esta diseñado para mantener un balance entre rendimiento y costo. Entre sus características principales están:

\begin{itemize}
	\item Cache de instrucciones
	\item Espacio de direcciones de hasta 2GB
	\item Pipeline de 5 etapas
	\item Productor de saltos estático
	\item Multiplicador y divisor por hardware. 
\end{itemize}



\subsubsection{Nios II/f}
El core Nios II/f esta diseñado para ofrecer la mayor performance a las expensas de un mayor tamaño, medido en unidades lógicas, este core tiene las siguientes características:

\begin{itemize}
	\item Cache de instrucciones y de datos separadas
	\item MMU y MPU opcionales
	\item Espacio de direcciones de hasta 2GB
	\item Pipeline de 6 etapas
	\item Multiplicador por hardware en un ciclo
	\item Divisor por hardware opcional
	\item Predictor de saltos dinámico
\end{itemize}




\subsection{SOPC}


\section{Interfaz Red-Procesador}
En esta sección se detallara la función de cada uno de los bloques que integran el modulo que sera el encargado de gestionar el flujo de datos y la comunicación con el procesador. 

\subsection{Interfaz de Red}
A los fines de poder trabajar con un entorno de prueba mas controlado se utilizara un generador de paquetes en remplazo de la interfaz de red propuesta en la figura XX. 
Este modulo debe ser altamente dramatizable para poder enfrentar el sistema a distintos escenarios. Dentro de los parámetros que se necesita variar se encuentran:

\begin{itemize}
	\item Tamaño de los paquetes 
	\item Distancia entre paquetes
	\item Campos internos de la cabecera IP. 
	\item Inicio y parada del flujo de datos. 
\end{itemize}

En el laboratorio en el cual se desarrollo este proyecto integrador se cuenta con el código de un generador y se buscara reutilizar dicho código.

\subsection{Modulo extractor de Cabeceras}
Bajo lo expuesto en el capitulo 2, se desprende que no se necesita transmitirle al procesador el paquete de datos entero, sino que solo la información presente en la cabecera es útil para la clasificación. Por esta razón, la interfaz Red-CPU solamente enviara al procesador las cabecera de cada paquete y mantendrá en espera del resultado los datos correspondientes al Payload. 

En la figura~\ref{fig:moduloprop} se puede ver los sub-módulos que componen el extractor de cabeceras, pasando a detallar la funcionalidad de cada uno a continuación

\begin{figure}[h]
  \centering
	\includegraphics[width=0.90\textwidth]{3-arquitectura/graf/modulo.eps}
  \caption{Estructura propuesta para el modulo propio}
  \label{fig:moduloprop}
\end{figure}



\subsubsection{FIFO}
A la entrada del modulo se encuentra una FIFO que se encarga de almacenar y poner a disposición en orden de llegada los datos que emite el generador. Además, para poder manipular los paquetes, la FIFO debe almacenar toda la información de control que este disponible. 
Este modulo también debe permitir la parametrización en la mayor cantidad de sentidos posibles, especialmente se desea poder configurar la cantidad de palabras disponibles que se puede almacenar, ya que la memoria dentro de una FPGA es un recurso critico y se desea encontrar la mejor relación entre rendimiento y uso de memoria.


\subsubsection{Delay Buffer}
El Componente Delay buffer sera el encargado de ir tomando los datos desde la FIFO y de detectar el inicio y finalización de un paquete. Además deberá mantener almacenado el paquete mientras el software toma una decisión. En este modulo es deseable poder configurar la cantidad de palabras que se consideraran parte de la cabecera y que sera enviadas al software. 

\subsubsection{Uplink}
Este Modulo es el encargado de realizar la comunicación entre el flujo de datos que proviene de la red y el procesador. Para ello debe entender las señales que utiliza el Bus, Avalon-MM, y poder interrumpir al procesador para enviarles los datos cuando estos estén disponibles. Cuando el procesador responde con el resultado de la clasificación, este modulo lo almacena y lo envía  write output para que este escriba el resultado de la clasificación en la etiqueta anexa al paquete correspondiente.
Eventualmente se desarrollaran varias versiones de este modulo, que envíen toda la cabecera o una parte selectiva de ella para optimizar así el rendimiento.

\subsubsection{Write Output}
Para finalizar, Write Output, toma la salida de Delay buffer y escribe el resultado que le envía Uplink en la etiqueta que se encuentra anexa a cada una de las palabras del paquete.


\subsection{Bus Avalon}

Avalon es una familia de interfaces para flujo de datos de alta velocidad, lectura/escritura de registros y memoria, y control de dispositivos "off-chip". Existen varios tipos, cuyo uso depende de las necesidades del diseño a implementar:
\begin{itemize}
	\item Avalon ST: Soporta flujo unidireccional de datos, incluyendo flujos multiplexados y paquetes.
	\item Avalon MM: Interfaz de lectura/escritura basada en memoria, típica de conexiones maestro-esclavo.
	\item Avalon Conduit Interface: Para señales que no se amoldan a los tipos anteriores.
	\item Avalon TC: Para dispositivos "off-chip".
	\item Avalon Interrupt Interface: Permite el envío de interrupciones entre componentes.
	\item Avalon Clock Interface: Recibe y/o distribuye señales de clock.
	\item Avalon Reset Interface.
\end{itemize}

En el diseño correspondiente a este trabajo se optó por utilizar las siguientes interfaces:

\begin{itemize}
	\item Avalon MM, debido a que los componentes están mapeados en la memoria del sistema.
	\item Avalon Clock Interface, para proveer señal de reloj al sistema.
	\item Avalon Interrupt Interface, para el componente que requiere interrumpir al procesador.
\end{itemize}

\subsubsection{Avalon MM}
Las señales de dicha interfaz necesarias para este diseño son:

\begin{itemize}
	\item address: Direcciona los datos enviados hacia y recibidos desde el procesador.
	\item chipselect: Se usa en combinacion con read/write.
	\item read: Indica una transferencia de lectura.
	\item readdata: Los datos transferidos desde el periférico hacia el procesador.
	\item write: Indica una transferencia de escritura.
	\item writedata: Los datos trasferidos desde el procesador hacia el periférico. Debe tener el mismo ancho que readdata.

\end{itemize}

\subsubsection{Avalon CLock Interface}
En este caso, la señal necesaria es
\begin{itemize}
	\item clk: Provee clock para sincronización en lógica interna y otras interfaces.
\end{itemize}

\subsubsection{Avalon Interrupt Interface}
Para esta interfaz, la señal a utilizar es

\begin{itemize}
	\item irq: Permite al periférico enviar una señal de interrupción al procesador.
\end{itemize}


\section{Software}

\subsection{NIOS II SBT}

El NIOS II Software Building Tools (o SBT) es un conjunto de utilidades y scripts que sirve para crear y construir aplicaciones embebidas basadas en C/C++, librerías de usuario y paquetes de soporte de placa (board support packages o BSP). 

Puede invocarse desde la IDE Eclipse o desde el intérprete de comandos del NIOS II.

El NIOS II SBT puede crear los siguientes tipos de proyecto:
\begin{itemize}
	\item Aplicación NIOS II: un programa que implementa alguna función deseada.
	\item NIOS II BSP: una librería que provee acceso al hardware en el sistema. Brinda un entorno de rutinas a medida para un procesador y, eventualmente, un sistema operativo. 
	\item Librería de usuario: un conjunto de funciones reutilizables. 
\end{itemize}

\subsubsection{Aplicaciones y librerías de usuario}

Para el caso de aplicaciones y librerías de usuario, el SBT genera un makefile privado (denominado \textbf{Makefile}) el cual es usado para construir el proyecto. Al hacer esto se genera un archivo .elf para una aplicación, o .a para una librería. En este último caso, también se produce un makefile público (denominado \textbf{public.mk}), que se incluye en el privado para cualquier aplicación que use la librería de usuario.

Cuando se crea un makefile se provee al SBT con una lista de archivos de código fuente y una referencia al directorio donde se almacena el BSP. Luego, la herramienta examina la extensión de cada archivo fuente para determinar el lenguaje de programación. 

Actualmente los soportados son:

\begin{itemize}
	\item C (extensión .c).
	\item C++ (extensiones .cpp, .cxx, .cc).
	\item NIOS II Assembler (extensiones .s, .S).
\end{itemize}


\subsubsection{Board Support Packages}

Un BSP es una librería especializada que contiene código de soporte específico del sistema. Aisla la aplicación de los detalles del sistema, tales como mapeo de memoria, dispositivos disponibles y configuración del procesador.

Se compone de:

\begin{itemize}
	\item Capa de abstracción de Hardware (Hardware Abstraction Layer o HAL): Permite al software interactuar con el hardware del sistema. Se describirá en detalle más adelante en este capítulo.
	\item Librería C estándar newlib: ANSI C estándar diseñada para sistemas embebidos.
	\item Drivers de dispositivos: para manejar cada uno de los componentes del sistema.
	\item Paquetes de software opcionales: permiten proveer funcionalidad adicional.
	\item Sistema operativo de tiempo real opcional: implementación de MicroC/OS-II RTOS.
\end{itemize}

\subsubsection{Proceso de construcción del software}

Para crear un proyecto de software se llevan a cabo una serie de pasos:

\begin{enumerate}
	\item Se obtiene el diseño de hardware sobre el cual va a correr el software. Dicha información está almacenada en un archivo de extensión \textbf{.sopcinfo}, el cual es generado por la herramienta SOPC builder.
	\item Se genera el BSP con las características necesarias según las funcionalidades requeridas. También se genera un makefile para dicho paquete.
	\item Opcionalmente, se crea una librería de usuario (junto a su correspondiente makefile).
	\item Se escribe el software de aplicación. Se colecta todo el código fuente, y luego se genera el makefile correspondiente.
	\item Se construye el proyecto.
\end{enumerate}


\subsection {HAL}

La Capa de Abstracción de Hardware \textit{(Hardware Abstraction Layer o HAL)} provee una interfaz simple de drivers de dispositivos para conectar los programas con el hardware subyacente. La API está integrada con la librería estándar ANSI C, lo cual permite al software acceder a los dispositivos mediante el uso de funciones C ampliamente conocidas, tales como printf(), fopen(), fwrite(), etc.

\subsubsection{Servicios}

La HAL provee los siguientes servicios:

\begin{itemize}
	\item Integración con la librería estándar newlib: provee funciones estándar ANSI C de amplio uso.
	\item Drivers de dispositivo: brinda acceso a cada dispositivo en el sistema.
	\item API: proporciona una interfaz estándar consistente a los servicios de la HAL, tales como acceso a dispositivos y manejo de interrupciones.
	\item Inicialización de sistema: Lleva a cabo la inicialización para el procesador y las rutinas antes de ejecutar la función principal (main).
	\item Inicialización de dispositivos: Instancia e inicializa cada uno de los dispositivos del sistema antes de que se ejecute la función main.
\end{itemize}

La figura ~\ref{fig:hal} muestra las capas de un sistema basado en la HAL, desde el nivel de hardware hasta el programa de usuario.

\begin{figure}[H]
  \centering
	\includegraphics[width=0.80\textwidth]{3-arquitectura/graf/hal.eps}
  \caption{Capas de un sistema basado en la HAL.}
  \label{fig:hal}
\end{figure}

\subsubsection{Modelos de dispositivos genéricos}

La HAL provee modelos de dispositivos genéricos para diversos tipos de periféricos que se encuentran en sistemas embebidos, tales como timers, interfaces Ethernet y dispositivos de I/O que transmiten datos de caracter. Estos modelos permiten escribir programas usando una API consistente sin preocuparse por el hardware subyacente.

Los tipos de periféricos cubiertos son:

\begin{itemize}
	\item Dispositivos de caracter: envían y/o reciben caracteres en forma serial, como ser una UART.
	\item Timers: dispositivos que llevan la cuenta de los tics de un clock y pueden generar interrupciones periódicas.
	\item Subsistemas de archivos: un mecanismo para acceder a archivos almacenados en dispositivos físicos. Dependiendo de la implementación interna, el driver del subsistema de archivos podría acceder a los dispositivos subyacentes en forma directa o usar un driver aparte.
	\item Dispositivos Ethernet: proveen acceso a una conexión Ethernet para una pila de red, tal como la NicheStack® TCP/IP Stack, provista por Altera.
	\item Dispositivos DMA: periféricos que llevan a cabo una gran cantidad de transacciones de datos. El origen y destino pueden ser la propia memoria o algún otro dispositivo.
	\item Dispositivos con memoria flash: periféricos con memoria no volátil que utilizan un protocolo especial de programación para almacenar datos.
\end{itemize}

Todos los periféricos, ya sean de Altera o de terceros, deben proveer un archivo de cabecera que defina la interfaz de bajo nivel del dispositivo con el hardware. 

Ciertos dispositivos tienen características específicas de hardware con requerimientos de uso que no se adaptan bien a una API de propósito general. La HAL maneja dichos requerimientos mediante la función ioctl(), cuyas opciones dependerán del periférico en cuestión.

Algunos periféricos proveen funciones de acceso dedicadas que no están basadas en el modelo genérico de la HAL. En ese caso, se debe proveer un archivo de cabecera con dichas funciones.


\subsubsection{Librería C estándar : newlib}
La HAL integra su entorno de rutinas con una implementación open-source de la librería C estándar:\textbf{ newlib}. La misma está hecha para ser utilizada en sistemas embebidos. 

\subsubsection{La HAL dentro de un proyecto de software}
La creación y administración de proyectos basados en la HAL están altamente ligadas al NIOS II SBT

\begin{figure}[h]
  \centering
	\includegraphics[width=0.90\textwidth]{3-arquitectura/graf/halsof.eps}
  \caption{Capas de un programa basado en HAL}
  \label{fig:halsof}
\end{figure}

La figura ~\ref{fig:halsof} muestra el diagrama en bloques de un software basado en la HAL. Todo programa de este tipo consta de dos proyectos. El código de aplicación específico se encuentra en uno de ellos, el cual depende a su vez de otro proyecto BSP separado.

EL primero contiene todo el código que el programador desarrolla. El segundo, toda la información necesaria para la interacción hardware-software. Este último a su vez depende del hardware del sistema, cuya información se encuentra en un archivo generado por la herramienta SOPC Builder.

\subsubsection{El archivo de descripción del sistema (system.h)}
El archivo system.h provee una descripción completa del software del sistema basado en NIOS II. Describe cada periférico e incluye:

\begin{itemize}
	\item La configuración de hardware del periférico.
	\item La dirección base.
	\item Información IRQ (si es necesario).
	\item Un nombre simbólico para el periférico.
\end{itemize}

El SBT genera un archivo \textbf{system.h} para cada proyecto BSP, cuyo contenido dependerá del archivo .sopcinfo mencionado anteriormente en este capítulo.

\subsubsection{Acceso al hardware}
El software accede al hardware a través de macros que abstraen la interfaz mapeada en memoria al dispositivo. Todos los componentes proveen un directorio que define el hardware y el software del periférico en cuestión. En esta carpeta se encuentra un archivo de cabecera que define la interfaz con el hardware y su nombre es $<componente>$\_regs.h, el cual se incluye en el subdirectorio inc. Por ejemplo, el componente JTAG UART define su interfaz en el archivo $<Directorio Instalación Altera>$/ip/altera/sopc\_builder\_ip/

altera\_avalon\_jtag\_uart/inc/altera\_avalon\_jtag\_uart\_regs.h.

El archivo de cabecera \_regs.h define las siguientes macros de acceso para el componente:
\begin{itemize}
	\item Macros de acceso a registros que proveen operaciones de lectura/escritura. Éstas son:
	\begin{itemize}
		\item IORD\_$<NombreDelComponente>$\_$<NombreDelRegistro>$ ($<DireccionBaseDelComponente>$).
		\item IOWR\_$<NombreDelComponente>$\_$<NombreDelRegistro>$ ($<DireccionBaseDelComponente>$, $<Dato>$).
	\end{itemize}
	\item Macros de direccionamiento de registro, que retornan las direcciones físicas de cada uno de ellos. La dirección devuelta es la dirección base del componente + el valor de desplazamiento de registro especificado. Esta macro tiene el nombre de esta forma:
	\begin{itemize}
		\item IOADDR\_$<NombreDelComponente>$\_$<NombreDelRegistro>$ ($<DireccionBaseDelComponente>$).
	\end{itemize}
	\item Máscaras a nivel de bits. Estas macros tienen los siguientes nombres:
	\begin{itemize}
		\item $<NombreDelComponente>$\_$<NombreDelRegistro>$\_$<NombreDelCampo>$\_MSK : Máscara de bit de un campo.
		\item $<NombreDelComponente>$\_$<NombreDelRegistro>$\_$<NombreDelCampo>$\_OFST : Desplazamiento de bit del el comienzo del campo.
	\end{itemize}
\end{itemize}

Cabe mencionar que las los valores leídos/escritos mediante las macros de acceso a registro (IORD e IOWR) no trabajan con la caché del microprocesador.
En este contexto, es necesario destacar esto ya que los valores intercambiados entre el módulo software y el gestor de datos tienen que ser leidos/escritos solamente si estos están en el bus.

\subsubsection{Criterio de selección: HAL vs. Sistema Operativo}

La razón de utilizar la HAL en vez de un sistema operativo, yace principalmente en la mayor simplicidad de uso que ésta presenta. En el caso de haber optado por el segundo enfoque hubiese sido necesario el desarrollo de drivers para el manejo de los dispositivos, con la complejidad que ello implica. La HAL, por otra parte, ofrece un conjunto de funciones de la librería estándar ANSI C para la interacción con el hardware del diseño, además de un conjunto de macros de fácil utilización, lo cual hace que dicha tarea sea significativamente más simple.


\begin{comment}
\subsection {Algoritmos de clasificación}

Se implementaron 2 algoritmos de clasificación: Búsqueda lineal y Búsqueda en árbol unibit.

El software utilizado para realizar las pruebas consistió en 2 proyectos por separado. Uno para cada tipo de búsqueda en la tabla.

El mismo fue desarrollado en lenguaje c++, por presentar éste ciertas facilidades para las implementaciones llevadas a cabo. Puntualmente se sacó ventaja de un STL container (list) para implementar la búsqueda lineal. La característica utilizada en este caso fue el ordenamiento de la lista con sólo una llamada a función.

Para efectuar el intercambio de datos con el hardware se hizo uso de las macros IOWR e IORD, las cuales escriben y leen respectivamente los datos hacia/desde un componente conectado al bus Avalon MM. La razón de haber usado dichas macros yace en el hecho de que las mismas no son puestas en caché. Esta característica se torna indispensable en este diseño, ya que en el mismo no se puede leer un dato sin saber si está verdaderamente disponible en el bus.


\subsubsection {Búsqueda lineal}

Se implementó en una lista enlazada, creada a partir del template list de c++. Los nodos de la lista contienen 3 campos:

\begin{itemize}
	\item Dirección de red (entero de 32 bit sin signo)
	\item Máscara de red (entero de 32 bit sin signo)
	\item Identificador de decisión (entero de 32 bit con signo)
\end{itemize}

Como se le dio prioridad a los prefijos de red más largos, se debió sobrecargar el operador de comparación ( > ) para que la función sort pudiese ordenar en base a la longitud de máscara. De esa manera, los nodos que contenían valores de máscara más grandes quedaban en las primeras posiciones de la lista.

Cuando la función encargada del lookup recibe una dirección IP de destino, realiza los siguientes pasos:

\begin{itemize}
	\item Coloca un iterador al comienzo de la lista.
	\item Realiza un AND con el valor de máscara del nodo que está siendo apuntado. Si el resultado de la operación es igual al valor de dirección de red de dicho nodo, entonces se retorna con el valor identificador de decisión. En otro caso, continúa la búsqueda en el siguiente nodo.
\end{itemize}

\subsubsection {Búsqueda en Árbol unibit}

Se implementó una clase en la cual se definieron las características de los nodos del árbol, como así también las operaciones de inserción y búsqueda.

En este contexto, pueden existir 2 tipos de nodo:

\begin{itemize}
	\item Común: no está asociado a una decisión.
	\item Decisión: contiene un valor que identifica a la decisión a tomar. 
\end{itemize}

Cada nodo cuenta con los siguientes campos:
\begin{itemize}
	\item gw: es un identificador de la decisión a tomar. En los nodos no asociados a una decisión, tiene el valor estipulado en la macro NONE.
    \item zero / one: Son punteros a nodo, asociados a los bits 0/1 del prefijo que se esté leyendo.

\end{itemize}




El algoritmo de búsqueda toma como entrada la dirección IP de destino del paquete a clasificar. Luego de ello, va haciendo un testeo bit a bit de la misma, partiendo con un puntero de recorrido desde el nodo raíz. Si el bit de la dirección es 0 y el puntero zero está apuntando hacia algún nodo, el puntero de recorrido se mueve al nodo apuntado por el puntero zero. En caso contrario, se mueve al nodo apuntado por el puntero one (En caso de que exista alguno). Esto se repite nodo a nodo, hasta que ocurre alguna de las siguientes situaciones:

\begin{itemize}
    	\item     El puntero de recorrido queda varado en un nodo decisión, con lo cual se retorna el valor de gw.
    	\item El puntero de recorrido queda varado en un nodo común. 
\end{itemize}



Contemplando esta última posibilidad, el algoritmo hace que en cada nodo se chequee si se trata de un nodo decisión. En dicho caso, se almacena el campo gw en una variable y se continua el recorrido. Si se da un caso en el cual el nodo de recorrido queda apuntando a un nodo común y luego de testear un bit se determina que el mismo no tiene un nodo asociado (es decir, que alguno de los punteros zero / one esté en NULL) la función retorna la variable anteriormente mencionada. 

\subsection {Cache}

Se implementó una cache directa. La misma consta de una tabla hash de 16 entradas. Las colisiones se resuelven por reemplazo directo. La misma fue testeada con ambos algoritmos mencionados anteriormente. Para ello, se agregó una lógica adicional que consistió en:

\begin{itemize}
	\item Al tomar una dirección IP, chequear primero si el valor de decisión se encuentra en caché.
	\item Si está, retornar dicho valor.
	\item En otro caso, efectuar el lookup y almacenar el valor de decisión en caché.
\end{itemize}

Para evitar el overhead introducido por el uso de clases, se optó por el uso de estructuras para la implementación de este último enfoque.


<<<<<<< HEAD
\begin{center}
	\begin{tabular}{|c|c|c|p{2.3cm}|p{2.3cm}|c|c|c|} \hline
		\textbf{Core} & \textbf{Arquitectura} & \textbf{Licencia} & \textbf{Profundidad del Pipeline} & \textbf{Ciclos por Instrucción} & \textbf{MMU} & \textbf{FPU} & \textbf{FPGA}\\ \hline
		MicroBlaze & MicroBlaze & Propietaria &	3,5 & 1 & Opt & Opt & Xilinx\\ \hline
		
	\end{tabular} 
\end{center}

\begin{comment}
=======
>>>>>>> 1db2de535272991722e31411032ebbcb176f49c9
\section{Parte HW}

\subsection{Componentes del sistema}

\subsubsection*{NIOS II}

Es un microprocesador Softcore. Esto significa que el mismo es instanciado usando la lógica propia de la FPGA. En este diseño, ejecuta un software de clasificación de paquetes que se almacena en una memoria SDRAM en la placa de desarrollo.

\subsubsection*{PLL}

Este módulo toma como entrada una señal de CLock de 50 MHZ de frecuencia y la bifurca en 2: Una de ellas alimentará al módulo que oficia de interfaz con la memoria SDRAM y la otra hará lo propio con el resto de los componentes del sistema. Estas señales están desfasadas entre sí 60º con el fin de evitar el SW producido por la diferencia entre la llegada del clock a la memoria y al resto del sistema.

\subsubsection*{Timer}

Módulo utilizado para llevar estadísticas de retardo dentro del software.

\subsubsection*{JTAG UART}

Este módulo permite interactuar con el sistema vía USB. Esto implica tanto la configuración de la FPGA, como también la posibilidad de ver la ejecución del software en una consola.

\subsubsection*{Interfaz con SDRAM}

Tiene la función de interconectar al sistema con la memoria SDRAM de la placa de desarrollo.

\subsubsection*{Extractor de cabeceras}

Este módulo extrae cabeceras de paquetes Ethernet y las envía al software, donde son procesadas y devueltas. Su funcionamiento se detallará a continuación.

\subsection{Módulo extractor de cabeceras}


(..esta parte completala vos...)

\section{Parte SW}

\section{Parte SW}

Se implementaron 2 algoritmos de clasificación: Búsqueda lineal y Búsqueda en árbol unibit.

El software utilizado para realizar las pruebas consistió en 2 proyectos por separado. Uno para cada tipo de búsqueda en la tabla.

El mismo fue desarrollado en lenguaje c++, por presentar éste ciertas facilidades para las implementaciones llevadas a cabo. Puntualmente se sacó ventaja de un STL container (list) para implementar la búsqueda lineal. Esta plantilla cuenta con, entre otras cosas, la posibilidad de ordenar la lista con sólo una llamada a función.

Para efectuar el intercambio de datos con el hardware se hizo uso de las macros IOWR e IORD, las cuales escriben y leen respectivamente los datos hacia/desde un componente conectado al bus Avalon MM. La razón de haber usado dichas macros yace en el hecho de que las mismas no son "cacheadas". Esta característica se torna indispensable en este diseño, ya que en el mismo no se puede leer un dato sin saber si está verdaderamente disponible en el bus.


\subsection {Búsqueda lineal}

Se implementó en una lista enlazada, creada a partir del template list de c++. Los nodos de la lista contienen 3 campos:

\begin{itemize}
	\item Dirección de red (entero de 32 bit sin signo)

	\item Máscara de red (entero de 32 bit sin signo)

	\item Identificador de decisión (entero de 32 bit con signo)
\end{itemize}

Como se le dio prioridad a los prefijos de red más largos, se debió sobrecargar el operador de comparación ( > ) para que la función sort pudiese ordenar en base a la longitud de máscara. De esa manera, los nodos que contenían valores de máscara más grandes quedaban en las primeras posiciones de la lista.

Cuando la función encargada del lookup recibe una dirección IP de destino, realiza los siguientes pasos:

\begin{itemize}
	\item Coloca un iterador al comienzo de la lista.
	\item Realiza un AND con el valor de máscara del nodo que está siendo apuntado. Si el resultado de la operación es igual al valor de dirección de red de dicho nodo, entonces se retorna con el valor identificador de decisión. En otro caso, continúa la búsqueda en el siguiente nodo.
\end{itemize}

\subsection {Búsqueda en Árbol unibit}

Se implementó una clase en la cual se definieron las características de los nodos del árbol, como así también las operaciones de inserción y búsqueda.
Cada nodo cuenta con los siguientes campos:
\begin{itemize}
	\item gw: es un identificador de la decisión a tomar. En los nodos no asociados a una decisión, tiene el valor estipulado en la macro NONE.
    \item zero / one: Son punteros a nodo, asociados a los bits 0/1 del prefijo que se esté leyendo.

\end{itemize}

En este contexto, pueden existir 2 tipos de nodo:

\begin{itemize}
	\item Común: Está asociado a la macro NONE. La misma lo diferencia del nodo decisión.
	\item Decisión: Contiene en el campo gw un valor que identifica a la decisión a tomar. 
\end{itemize}



El algoritmo de búsqueda toma como entrada la dirección IP de destino del paquete a clasificar. Luego de ello, va haciendo un testeo bit a bit de la misma, partiendo con un puntero de recorrido desde el nodo raíz. Si el bit de la dirección es 0 y el puntero zero está apuntando hacia algún nodo, el puntero de recorrido se mueve al nodo apuntado por el puntero zero. En caso contrario, se mueve al nodo apuntado por one (En caso de que exista). Esto se repite nodo a nodo, hasta que:

\begin{itemize}
    	\item     El puntero de recorrido queda varado en un nodo decisión, con lo cual se retorna el valor de gw. Ó
    	\item El puntero de recorrido queda varado en un nodo común. 
\end{itemize}



Contemplando esta última posibilidad, el algoritmo hace que en cada nodo se chequee si se trata de un nodo decisión. En dicho caso, se almacena el campo gw en una variable y se continua el recorrido. Si se da un caso en el cual el nodo de recorrido queda apuntando a un nodo común y luego de testear un bit se determina que el mismo no tiene un nodo asociado (es decir, que alguno de los punteros zero / one esté en NULL) la función retorna la variable anteriormente mencionada. 

\subsection {Cache}

Se implementó una cache directa. La misma consta de una tabla hash de 16 entradas. Las colisiones se resuelven por reemplazo directo. La misma fue testeada con ambos algoritmos mencionados anteriormente. Para ello, se agregó una lógica adicional que consistió en:

\begin{itemize}
	\item Al tomar una dirección IP, chequear primero si el valor de decisión se encuentra en caché.
	\item Si está, retornar dicho valor.
	\item En otro caso, efectuar el lookup y almacenar el valor de decisión en caché.
\end{itemize}
\end{comment}


